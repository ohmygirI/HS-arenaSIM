<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>íˆ¬ê¸°ì¥ ì‹œë®¬ë ˆì´í„° 2025</title>
<style>
  body { background-color: #f8f8f8; text-align: center; font-family: 'Gmarket Sans', sans-serif; transition: background-color 0.5s ease; margin: 0; padding: 20px; }
  .title { font-size: 40px; margin-top: 30px; font-weight: bold; }
  
  .btn { border: 3px solid #d32f2f; border-radius: 20px; display: inline-block; padding: 8px 20px; color: #d32f2f; font-size: 18px; margin: 10px; cursor: pointer; transition: 0.2s; background: white; user-select: none; }
  .btn:hover { background-color: #d32f2f; color: white; }
  .btn.active { background-color: #d32f2f; color: white; }
  .dev-entry-btn { border-color: #333; color: #333; }
  .dev-entry-btn:hover { background-color: #333; color: white; }

  /* íŒ© ì„ íƒ í™”ë©´ */
  .pack-filter-container { margin: 20px auto; max-width: 800px; text-align: center; display: flex; flex-direction: column; align-items: center; gap: 10px; }
  .pack-select-dropdown { padding: 15px; font-size: 18px; width: 100%; border-radius: 10px; border: 2px solid #555; background: white; cursor: pointer; }
  .legacy-toggle-area { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }
  .toggle-btn { border: 2px solid #555; padding: 8px 15px; border-radius: 20px; cursor: pointer; background: #eee; color: #aaa; font-weight: bold; }
  .toggle-btn.checked { background: #4CAF50; color: white; border-color: #4CAF50; }

  .selected-packs-area { min-height: 60px; margin: 20px auto; max-width: 1000px; padding: 10px; border: 2px dashed #d32f2f; border-radius: 10px; background: #fff5f5; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; align-items: center; }
  .selected-packs-label { width: 100%; font-size: 14px; color: #d32f2f; margin-bottom: 5px; font-weight: bold; }
  
  .packs-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 15px; justify-content: center; max-width: 1200px; margin: 20px auto; }
  .pack-card { border: 2px solid #555; padding: 15px; cursor: pointer; background-color: white; border-radius: 10px; transition: 0.2s; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 80px; word-break: keep-all; line-height: 1.3; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
  .pack-card:hover { transform: translateY(-3px); box-shadow: 0 5px 10px rgba(0,0,0,0.15); }
  .pack-card.selected { background-color: #fff9c4; border-color: #fbc02d; font-weight: bold; box-shadow: 0 0 0 2px #fbc02d; }
  .pack-year-tag { font-size: 12px; color: #888; margin-bottom: 5px; }
  .pack-name { font-size: 15px; font-weight: bold; }

  /* ê³µí†µ ë ˆì´ì•„ì›ƒ */
  .layout { display: flex; justify-content: center; align-items: flex-start; gap: 30px; margin-top: 30px; flex-wrap: wrap; }
  .heroes { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px; justify-content: center; max-width: 1000px; margin: 30px auto; }
  .card-container { display: flex; gap: 20px; justify-content: center; }
  .card-wrapper { display: flex; flex-direction: column; align-items: center; transition: transform 0.2s; }
  .card-wrapper:hover { transform: scale(1.05); }
  .hero-img { width: 150px; height: 220px; cursor: pointer; background-size: cover; background-position: center; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
  .card { width: 200px; height: 300px; cursor: pointer; background-size: contain; background-repeat: no-repeat; background-position: center; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.3)); }
  .deck { border: 2px solid #333; width: 250px; height: 600px; overflow-y: auto; padding: 15px; text-align: left; background: white; border-radius: 10px; }
  .deck-item { display: flex; align-items: center; background-color: #222; color: white; padding: 6px; margin: 4px 0; border-radius: 4px; font-size: 14px; }
  .mana-cost { background-color: #0070DE; color: white; width: 22px; height: 22px; display: flex; align-items: center; justify-content: center; border-radius: 50%; margin-right: 8px; font-weight: bold; font-size: 12px; }
  
  .rune-container { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; background: #333; padding: 10px 20px; border-radius: 20px; display: inline-flex; }
  .rune-slot { width: 30px; height: 30px; border-radius: 50%; border: 2px solid #555; background-color: #222; display: flex; align-items: center; justify-content: center; font-size: 18px; }
  .rune-blood { background-color: #C41E3A; border-color: #ff4d4d; box-shadow: 0 0 10px #C41E3A; }
  .rune-frost { background-color: #0070DE; border-color: #4da6ff; box-shadow: 0 0 10px #0070DE; }
  .rune-unholy { background-color: #40C040; border-color: #80ff80; box-shadow: 0 0 10px #40C040; }
  .rune-empty { background-color: #444; }

  /* ë§ˆë‚˜ ì»¤ë¸Œ UI */
  .mana-curve-container { position: absolute; top: 20px; right: 20px; background: white; padding: 10px; border: 2px solid #333; border-radius: 10px; width: 200px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
  .mana-curve-title { font-weight: bold; font-size: 14px; margin-bottom: 5px; text-align: center; }
  .mana-graph { display: flex; justify-content: space-around; align-items: flex-end; height: 100px; border-bottom: 1px solid #ccc; }
  .mana-bar-group { display: flex; flex-direction: column; align-items: center; width: 20px; }
  .mana-bar { width: 100%; background-color: #0070DE; border-radius: 3px 3px 0 0; transition: height 0.3s; min-height: 0; }
  .mana-label { font-size: 10px; margin-top: 2px; }
  .mana-count { font-size: 10px; margin-bottom: 2px; font-weight: bold; }

  /* ê°œë°œì í˜ì´ì§€ */
  .dev-header { display: flex; justify-content: space-between; align-items: flex-start; max-width: 1200px; margin: 0 auto 20px auto; padding: 15px; background: white; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); flex-wrap: wrap; gap: 20px; }
  .dev-search-area { text-align: left; flex: 1; min-width: 300px; }
  .dev-search-input { width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 5px; box-sizing: border-box; }
  
  .dev-filter-area { text-align: right; flex: 2; display: flex; flex-direction: column; gap: 8px; align-items: flex-end; }
  .filter-row { display: flex; align-items: center; gap: 5px; flex-wrap: wrap; justify-content: flex-end; width: 100%; }
  .filter-btn { border: 1px solid #ccc; background: white; padding: 6px 12px; cursor: pointer; border-radius: 15px; font-size: 12px; color: #555; transition: 0.2s; margin: 2px; }
  .filter-btn:hover { background-color: #f0f0f0; }
  .filter-btn.active { background-color: #333; color: white; border-color: #333; font-weight: bold; }
  
  .dev-layout { display: flex; flex-wrap: wrap; justify-content: center; gap: 7px 10px; padding: 20px; }
  .dev-card-box { display: flex; flex-direction: column; align-items: center; position: relative; }
  .dev-card-img { width: 150px; height: 225px; background-size: contain; background-repeat: no-repeat; background-position: center; }
  .ban-checkbox { width: 10px; height: 10px; border: 1px solid black; background-color: white; margin-top: 5px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
  .ban-checkbox.checked { background-color: red; }
  .ban-inner { width: 5px; height: 5px; background-color: transparent; }
  .ban-checkbox.checked .ban-inner { background-color: red; }
  .banned-overlay { position: absolute; top:0; left:0; width: 100%; height: 225px; background-color: rgba(255, 0, 0, 0.3); pointer-events: none; display: none; }
  .ban-checkbox.checked ~ .banned-overlay { display: block; }
  .loading { font-size: 24px; font-weight: bold; color: #555; margin-top: 50px; }

  /* ìŒì•… ë²„íŠ¼ */
  .music-control { 
      position: fixed; bottom: 20px; right: 20px; 
      width: 50px; height: 50px; 
      background: white; border: 3px solid #333; border-radius: 50%; 
      display: flex; align-items: center; justify-content: center; 
      font-size: 24px; cursor: pointer; z-index: 1000; 
      box-shadow: 0 4px 8px rgba(0,0,0,0.2); transition: 0.2s;
  }
  .music-control:hover { transform: scale(1.1); }
  .music-control.off { background: #ddd; color: #777; border-color: #777; }

</style>
</head>
<body>

<div id="content"></div>

<script>
const content = document.getElementById('content');

// --- ì˜¤ë””ì˜¤ ì„¤ì • ---
const audioMain = new Audio('Hearthstone Main.mp3');
const audioBrawl = new Audio('Hearthstone Tavern Brawl Main.mp3');
audioMain.loop = true;
audioBrawl.loop = true;
audioMain.volume = 0.4;
audioBrawl.volume = 0.4;

let currentAudio = null;
let isMuted = false;

function playMusic(audioObj) {
    if (currentAudio === audioObj && !currentAudio.paused) return; 
    if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
    }
    currentAudio = audioObj;
    if (!isMuted) {
        currentAudio.play().catch(e => console.log("Audio play failed:", e));
    }
}

function stopMusic() {
    if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
        currentAudio = null;
    }
}

function toggleMute() {
    isMuted = !isMuted;
    const btn = document.getElementById('musicBtn');
    if (isMuted) {
        if (currentAudio) currentAudio.pause();
        if (btn) { btn.innerHTML = 'ğŸ”‡'; btn.classList.add('off'); }
    } else {
        if (currentAudio) currentAudio.play();
        if (btn) { btn.innerHTML = 'ğŸ”Š'; btn.classList.remove('off'); }
    }
}

function renderMusicBtn() {
    if (document.getElementById('musicBtn')) return;
    const btn = document.createElement('div');
    btn.id = 'musicBtn';
    btn.className = 'music-control';
    btn.innerHTML = isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
    if (isMuted) btn.classList.add('off');
    btn.onclick = toggleMute;
    document.body.appendChild(btn);
}

// ----------------------------------------------------

let allCardsData = null;
let bannedCardIds = new Set(); 

// ì˜µì…˜ ìƒíƒœ
let includeCore = true;    
let includeLegacy = false;
let includeVanilla = false;

// ê°œë°œì í˜ì´ì§€ í•„í„° ìƒíƒœ
let devState = {
    search: '',
    filters: {
        classType: new Set(),
        cardType: new Set(),
        rarity: new Set(),
        sets: new Set()
    }
};

const hearthstoneYears = [
    {
        year: 2025, name: "ë©í„°ì˜ í•´",
        sets: [
            { id: 'TIME_TRAVEL', name: 'ì‹œê°„ì˜ ê¸¸ ë„ˆë¨¸ë¡œ' }, 
            { id: 'EMERALD_DREAM', name: 'ì—ë©”ë„ë“œì˜ ê¿ˆ ì†ìœ¼ë¡œ' }, 
            { id: 'THE_LOST_CITY', name: 'ìš´ê³ ë¡œì˜ ìƒì–´ë²„ë¦° ë„ì‹œ' } 
        ]
    },
    {
        year: 2024, name: "í˜ê°€ìˆ˜ìŠ¤ì˜ í•´",
        sets: [
            { id: 'SPACE', name: 'ëì—†ëŠ” ì–´ë‘ ' },
            { id: 'ISLAND_VACATION', name: 'ê·¹í•œì˜ ê·¹ë½' },
            { id: 'WHIZBANGS_WORKSHOP', name: 'ìœ„ì¦ˆë±…ì˜ ì¥ë‚œê° ê³µë°©' }
        ]
    },
    { year: 2023, name: "ëŠ‘ëŒ€ì˜ í•´", sets: [{ id: 'WILD_WEST', name: 'í™©ì•¼ì˜ ë•… ê²°íˆ¬' }, { id: 'TITANS', name: 'í‹°íƒ„' }, { id: 'BATTLE_OF_THE_BANDS', name: 'ì „ì„¤ ë…¸ë˜ìë‘' }] },
    { year: 2022, name: "íˆë“œë¼ì˜ í•´", sets: [{ id: 'RETURN_OF_THE_LICH_KING', name: 'ë¦¬ì¹˜ì™•ì˜ ì§„êµ°' }, { id: 'REVENDRETH', name: 'ë‚˜ìŠ¤ë¦¬ì•„ ì„±ì±„ ì‚´ì¸ ì‚¬ê±´' }, { id: 'THE_SUNKEN_CITY', name: 'ê°€ë¼ì•‰ì€ ë„ì‹œë¡œì˜ í•­í•´' }] },
    { year: 2021, name: "ê·¸ë¦¬í°ì˜ í•´", sets: [{ id: 'ALTERAC_VALLEY', name: 'ì•Œí„°ë ‰ ê³„ê³¡' }, { id: 'STORMWIND', name: 'ìŠ¤í†°ìœˆë“œ' }, { id: 'THE_BARRENS', name: 'ë¶ˆëª¨ì˜ ë•…' }] },
    { year: 2020, name: "ë¶ˆì‚¬ì¡°ì˜ í•´", sets: [{ id: 'DARKMOON_FAIRE', name: 'ê´‘ê¸°ì˜ ë‹¤í¬ë¬¸ ì¶•ì œ' }, { id: 'SCHOLOMANCE', name: 'ìŠ¤ì¹¼ë¡œë§¨ìŠ¤ ì•„ì¹´ë°ë¯¸' }, { id: 'BLACK_TEMPLE', name: 'í™©íí•œ ì•„ì›ƒëœë“œ' }] },
    { year: 2019, name: "ìš©ì˜ í•´", sets: [{ id: 'DRAGONS', name: 'ìš©ì˜ ê°•ë¦¼' }, { id: 'ULDUM', name: 'ìš¸ë‘ ì˜ êµ¬ì›ì' }, { id: 'DALARAN', name: 'ì–´ë‘ ì˜ ë°˜ê²©' }] },
    { year: 2018, name: "ê¹Œë§ˆê·€ì˜ í•´", sets: [{ id: 'TROLL', name: 'ë¼ìŠ¤íƒ€ì¹¸ì˜ ëŒ€ë‚œíˆ¬' }, { id: 'BOOMSDAY', name: 'ë°•ì‚¬ ë¶ì˜ í­ì‹¬ë§Œë§Œ í”„ë¡œì íŠ¸' }, { id: 'GILNEAS', name: 'ë§ˆë…€ìˆ²' }] },
    { year: 2017, name: "ë§¤ë¨¸ë“œì˜ í•´", sets: [{ id: 'LOOTAPALOOZA', name: 'ì½”ë³¼íŠ¸ì™€ ì§€í•˜ ë¯¸ê¶' }, { id: 'ICECROWN', name: 'ì–¼ì–´ë¶™ì€ ì™•ì¢Œì˜ ê¸°ì‚¬ë“¤' }, { id: 'UNGORO', name: 'ìš´ê³ ë¡œë¥¼ í–¥í•œ ì—¬ì •' }] },
    { year: 2016, name: "í¬ë¼ì¼„ì˜ í•´", sets: [{ id: 'GANGS', name: 'ë¹„ì—´í•œ ê±°ë¦¬ì˜ ê°€ì ¯ì”' }, { id: 'KARA', name: 'í•œì—¬ë¦„ ë°¤ì˜ ì¹´ë¼ì”' }, { id: 'OG', name: 'ê³ ëŒ€ ì‹ ì˜ ì†ì‚­ì„' }] },
    { year: 2015, name: "2015ë…„", sets: [{ id: 'LOE', name: 'íƒí—˜ê°€ ì—°ë§¹' }, { id: 'TGT', name: 'ëŒ€ ë§ˆìƒì‹œí•©' }, { id: 'BRM', name: 'ê²€ì€ë°”ìœ„ ì‚°' }] },
    { year: 2014, name: "2014ë…„", sets: [{ id: 'GVG', name: 'ê³ ë¸”ë¦° ëŒ€ ë…¸ì›€' }, { id: 'NAXX', name: 'ë‚™ìŠ¤ë¼ë§ˆìŠ¤ì˜ ì €ì£¼' }] }
];

const flatPackList = [];
hearthstoneYears.forEach(y => { y.sets.forEach(s => { flatPackList.push({ ...s, year: y.year, yearName: y.name }); }); });

let selectedPackIDs = []; 
let selectedHero = '';
let deck = [];

const heroes = ['ì„±ê¸°ì‚¬','ì „ì‚¬','ì•…ë§ˆ ì‚¬ëƒ¥ê¾¼','ë„ì ','ì‚¬ì œ','ë“œë£¨ì´ë“œ','í‘ë§ˆë²•ì‚¬','ë§ˆë²•ì‚¬','ì£½ìŒì˜ ê¸°ì‚¬','ì£¼ìˆ ì‚¬','ì‚¬ëƒ¥ê¾¼'];

// ë± ì½”ë“œ ìƒì„±ì„ ìœ„í•œ DBF ID ë§¤í•‘
const heroDbfIdMap = {
  'ì„±ê¸°ì‚¬': 671,
  'ì „ì‚¬': 7,
  'ì•…ë§ˆ ì‚¬ëƒ¥ê¾¼': 56550,
  'ë„ì ': 930,
  'ì‚¬ì œ': 813,
  'ë“œë£¨ì´ë“œ': 274,
  'í‘ë§ˆë²•ì‚¬': 893,
  'ë§ˆë²•ì‚¬': 637,
  'ì£½ìŒì˜ ê¸°ì‚¬': 78065,
  'ì£¼ìˆ ì‚¬': 1066,
  'ì‚¬ëƒ¥ê¾¼': 31
};

const heroImageMap = {
  'ì„±ê¸°ì‚¬': 'HERO_04', 'ì „ì‚¬': 'HERO_01', 'ì•…ë§ˆ ì‚¬ëƒ¥ê¾¼': 'HERO_10', 'ë„ì ': 'HERO_03', 'ì‚¬ì œ': 'HERO_09',
  'ë“œë£¨ì´ë“œ': 'HERO_06', 'í‘ë§ˆë²•ì‚¬': 'HERO_07', 'ë§ˆë²•ì‚¬': 'HERO_08', 'ì£½ìŒì˜ ê¸°ì‚¬': 'HERO_11', 'ì£¼ìˆ ì‚¬': 'HERO_02', 'ì‚¬ëƒ¥ê¾¼': 'HERO_05'
};

const heroClassMap = {
  'ì„±ê¸°ì‚¬': 'PALADIN', 'ì „ì‚¬': 'WARRIOR', 'ì•…ë§ˆ ì‚¬ëƒ¥ê¾¼': 'DEMONHUNTER', 'ë„ì ': 'ROGUE', 'ì‚¬ì œ': 'PRIEST',
  'ë“œë£¨ì´ë“œ': 'DRUID', 'í‘ë§ˆë²•ì‚¬': 'WARLOCK', 'ë§ˆë²•ì‚¬': 'MAGE', 'ì£½ìŒì˜ ê¸°ì‚¬': 'DEATHKNIGHT', 'ì£¼ìˆ ì‚¬': 'SHAMAN', 'ì‚¬ëƒ¥ê¾¼': 'HUNTER'
};

const rarityColorMap = { 'FREE': '#777', 'COMMON': '#777', 'RARE': '#0070dd', 'EPIC': '#a335ee', 'LEGENDARY': '#ff8000' };

async function loadCardData() {
    if (allCardsData) return;
    content.innerHTML = `<div class='loading'>ì¹´ë“œ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...<br>(ì´ˆê¸° 1íšŒ ë¡œë”©ì´ í•„ìš”í•©ë‹ˆë‹¤)</div>`;
    try {
        const res = await fetch('https://api.hearthstonejson.com/v1/latest/koKR/cards.collectible.json');
        allCardsData = await res.json();
        mainScreen();
    } catch (e) {
        content.innerHTML = `<div class='title'>ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨</div><p>ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”.</p>`;
    }
}

function mainScreen() {
  selectedPackIDs = []; 
  deck = []; 
  bannedCardIds.clear(); 
  
  includeCore = true;
  includeLegacy = false;
  includeVanilla = false;
  
  renderMusicBtn();
  stopMusic();

  content.innerHTML = `<div class='title'>íˆ¬ê¸°ì¥ ì‹œë®¬ë ˆì´í„° 2025</div><div class='btn' onclick='startApp()'>ì‹œì‘í•˜ê¸°</div>`;
}

function startApp() {
    playMusic(audioMain); 
    selectPacks();
}

function selectPacks() {
  content.innerHTML = `
      <div class='title'>í™•ì¥íŒ© ì„ íƒ (ìµœëŒ€ 6ê°œ)</div>
      <div class='pack-filter-container'>
          <select id='yearFilter' class='pack-select-dropdown' onchange='renderPackGrid()'>
              <option value='ALL'>ì „ì²´ ë³´ê¸°</option>
              ${hearthstoneYears.map(y => {
                  const setNames = y.sets.map(s => s.name).join(', ');
                  return `<option value='${y.year}'>${y.year}ë…„ - ${y.name} - ${setNames}</option>`;
              }).join('')}
          </select>
          
          <div class='legacy-toggle-area'>
             <div class='toggle-btn ${includeCore ? 'checked' : ''}' onclick='toggleCore(this)'>í•µì‹¬ (CORE)</div>
             <div class='toggle-btn ${includeLegacy ? 'checked' : ''}' onclick='toggleLegacy(this)'>ê³ ì „ (LEGACY)</div>
             <div class='toggle-btn ${includeVanilla ? 'checked' : ''}' onclick='toggleVanilla(this)'>ê¸°ë³¸ (VANILLA)</div>
          </div>
      </div>
      <div class='selected-packs-area' id='selectedArea'></div>
      <div class='packs-grid' id='packGrid'></div>
      <div class='layout'><div class='btn' onclick='mainScreen()'>ì²˜ìŒìœ¼ë¡œ</div><div class='btn' onclick='selectHeroes()'>ì˜ì›… ì„ íƒ</div></div>
  `;
  renderPackGrid();
  renderSelectedPacks();
}

function toggleCore(btn) { includeCore = !includeCore; btn.classList.toggle('checked'); }
function toggleLegacy(btn) { includeLegacy = !includeLegacy; btn.classList.toggle('checked'); }
function toggleVanilla(btn) { includeVanilla = !includeVanilla; btn.classList.toggle('checked'); }

function renderPackGrid() {
    const filterValue = document.getElementById('yearFilter').value;
    const grid = document.getElementById('packGrid');
    grid.innerHTML = '';
    let displayPacks = (filterValue === 'ALL') ? flatPackList : flatPackList.filter(p => p.year === parseInt(filterValue));
    displayPacks.forEach(pack => {
        const div = document.createElement('div');
        div.className = 'pack-card';
        if (selectedPackIDs.includes(pack.id)) div.classList.add('selected');
        div.innerHTML = `<div class='pack-year-tag'>${pack.year} ${pack.yearName}</div><div class='pack-name'>${pack.name}</div>`;
        div.onclick = () => togglePackSelection(pack.id);
        grid.appendChild(div);
    });
}

function togglePackSelection(id) {
    if (selectedPackIDs.includes(id)) selectedPackIDs = selectedPackIDs.filter(pid => pid !== id);
    else if (selectedPackIDs.length < 6) selectedPackIDs.push(id);
    else { alert('ìµœëŒ€ 6ê°œê¹Œì§€ ì„ íƒ ê°€ëŠ¥í•©ë‹ˆë‹¤.'); return; }
    renderPackGrid(); renderSelectedPacks();
}

function renderSelectedPacks() {
    const area = document.getElementById('selectedArea');
    const count = selectedPackIDs.length;
    const selectedObjects = selectedPackIDs.map(id => flatPackList.find(p => p.id === id));
    let html = `<div class='selected-packs-label'>ì„ íƒëœ í™•ì¥íŒ© (${count}/6)</div>`;
    if (count === 0) html += `<span style='color:#999; font-size:14px;'>í™•ì¥íŒ©ì„ ì„ íƒí•˜ì„¸ìš”.</span>`;
    else selectedObjects.forEach(pack => { html += `<div class='btn' style='font-size:14px; padding:5px 10px; margin:2px; pointer-events:none; border-width:1px;'>${pack.name}</div>`; });
    area.innerHTML = html;
}

function selectHeroes() {
  const randomHeroes = heroes.sort(() => 0.5 - Math.random()).slice(0,3);
  content.innerHTML = `<div class='title'>ì˜ì›… ì„ íƒ</div><div class='heroes' id='heroes' style='margin-top:20px;'></div><div style='margin-top:30px;'><div class='btn' onclick='selectPacks()'>ë’¤ë¡œê°€ê¸°</div></div>`;
  const heroDiv = document.getElementById('heroes');
  randomHeroes.forEach(hero => {
    const wrapper = document.createElement('div');
    wrapper.className = 'card-wrapper';
    const div = document.createElement('div');
    div.className = 'hero-img';
    div.style.backgroundImage = `url('https://art.hearthstonejson.com/v1/render/latest/koKR/512x/${heroImageMap[hero]}.png')`;
    div.onclick = () => { 
        selectedHero = hero; 
        deck = []; 
        playMusic(audioBrawl); 
        selectCards(true); 
    };
    const text = document.createElement('div'); text.innerText = hero; text.style.marginTop = '10px'; text.style.fontWeight = 'bold';
    wrapper.appendChild(div); wrapper.appendChild(text); heroDiv.appendChild(wrapper);
  });
}

function updateDeck() {
  const deckDiv = document.getElementById('deck'); if(!deckDiv) return;
  const cardCount = {};
  deck.forEach(card => {
    const key = `${card.name}-${card.cost}`;
    if (!cardCount[key]) cardCount[key] = { ...card, count: 0 };
    cardCount[key].count++;
  });
  const sortedCards = Object.values(cardCount).sort((a, b) => a.cost - b.cost);
  deckDiv.innerHTML = `<div style='margin-bottom: 10px; font-weight: bold; border-bottom: 2px solid #eee; padding-bottom: 5px;'>ë± ë¦¬ìŠ¤íŠ¸ (${deck.length}/30)</div>` + 
  sortedCards.map(card => {
    const rarityColor = rarityColorMap[card.rarity] || '#777';
    return `<div class='deck-item' style='border-left: 5px solid ${rarityColor};'><div class='mana-cost'>${card.cost}</div><div style='flex:1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;'>${card.name}</div>${card.count > 1 ? `<div style='font-weight:bold; color:gold; margin-left:5px;'>x${card.count}</div>` : ''}</div>`;
  }).join('');
}

function renderManaCurve() {
    const counts = [0,0,0,0,0,0,0,0]; // 0~7+
    deck.forEach(c => {
        let cost = c.cost || 0;
        if(cost > 7) cost = 7;
        counts[cost]++;
    });
    const max = Math.max(...counts, 1);
    
    let html = `<div class='mana-curve-container'><div class='mana-curve-title'>ë§ˆë‚˜ ì»¤ë¸Œ</div><div class='mana-graph'>`;
    counts.forEach((count, idx) => {
        const height = (count / max) * 80; 
        const label = idx === 7 ? '7+' : idx;
        html += `
            <div class='mana-bar-group'>
                <div class='mana-count'>${count > 0 ? count : ''}</div>
                <div class='mana-bar' style='height:${height}px;'></div>
                <div class='mana-label'>${label}</div>
            </div>`;
    });
    html += `</div></div>`;
    return html;
}

function getCurrentRunes() {
    let maxBlood = 0, maxFrost = 0, maxUnholy = 0;
    deck.forEach(c => {
        maxBlood = Math.max(maxBlood, c.blood || 0);
        maxFrost = Math.max(maxFrost, c.frost || 0);
        maxUnholy = Math.max(maxUnholy, c.unholy || 0);
    });
    return { blood: maxBlood, frost: maxFrost, unholy: maxUnholy };
}

/* ------------------------------
   ê°œë°œì ëª¨ë“œ & í•„í„°
   ------------------------------ */
let baseDevCards = []; 

function authDeveloperMode() {
    const pw = prompt("ê´€ë¦¬ì ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.");
    if (pw === '0220') initDeveloperPage();
    else if (pw !== null) alert("ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
}

function getActiveSets() {
    const packs = [];
    if (includeCore) packs.push('CORE');
    if (includeLegacy) packs.push('LEGACY');
    if (includeVanilla) packs.push('VANILLA');
    
    selectedPackIDs.forEach(id => {
        packs.push(id);
    });
    return packs;
}

function initDeveloperPage() {
    if (!allCardsData || !selectedHero) return;
    
    devState = { search: '', filters: { classType: new Set(), cardType: new Set(), rarity: new Set(), sets: new Set() } };

    const heroClass = heroClassMap[selectedHero];
    const activeSets = getActiveSets();

    baseDevCards = allCardsData.filter(card => {
        const bannedTypes = ['ENCHANTMENT', 'HERO_POWER'];
        const bannedIds = ['GDB_905', 'AT_COIN', 'VAC_320']; 
        if (bannedTypes.includes(card.type)) return false;
        if (bannedIds.includes(card.id)) return false;
        if (card.name.trim().toLowerCase() === '???') return false;
        if (!['MINION', 'SPELL', 'WEAPON', 'HERO', 'LOCATION', 'QUEST'].includes(card.type)) return false;
        if (!card.set || !activeSets.includes(card.set)) return false;

        if (card.classes && card.classes.length > 0) {
            const isPureNeutral = card.classes.length === 1 && card.classes[0] === 'NEUTRAL';
            if (!isPureNeutral && !card.classes.includes(heroClass)) return false;
        } else {
            if (card.cardClass !== heroClass && card.cardClass !== 'NEUTRAL') return false;
        }
        return true;
    });

    baseDevCards.sort((a,b) => a.cost - b.cost);
    renderDevUI();
    updateDevGrid();
}

function getSetName(setId) {
    if (setId === 'CORE') return 'í•µì‹¬';
    if (setId === 'LEGACY') return 'ê³ ì „';
    if (setId === 'VANILLA') return 'ê¸°ë³¸';
    const packObj = flatPackList.find(p => p.id === setId);
    if (packObj) return packObj.name;
    return setId;
}

function renderDevUI() {
    const hasLocation = baseDevCards.some(c => c.type === 'LOCATION');
    const activeSets = getActiveSets();

    let setButtons = '';
    activeSets.forEach(setId => {
        let name = getSetName(setId);
        setButtons += `<button class='filter-btn' onclick="toggleFilter('sets', '${setId}')">${name}</button>`;
    });

    content.innerHTML = `
        <div class='dev-header'>
            <div class='dev-search-area'>
                <div style='font-weight:bold; margin-bottom:5px;'>ğŸ” ì¹´ë“œ ê²€ìƒ‰</div>
                <input type='text' id='devSearch' class='dev-search-input' placeholder='ì¹´ë“œ ì´ë¦„ ê²€ìƒ‰...'>
            </div>
            
            <div class='dev-filter-area'>
                <div style='font-weight:bold; font-size:14px; margin-bottom:5px; color:#555;'>ê²°ê³¼ í™•ì¸ìš© í•„í„°</div>
                <div class='filter-row'>
                    <button class='filter-btn' onclick="toggleFilter('classType', 'CLASS')">ì§ì—…</button>
                    <button class='filter-btn' onclick="toggleFilter('classType', 'NEUTRAL')">ì¤‘ë¦½</button>
                </div>
                <div class='filter-row'>
                    <button class='filter-btn' onclick="toggleFilter('cardType', 'MINION')">í•˜ìˆ˜ì¸</button>
                    <button class='filter-btn' onclick="toggleFilter('cardType', 'SPELL')">ì£¼ë¬¸</button>
                    <button class='filter-btn' onclick="toggleFilter('cardType', 'WEAPON')">ë¬´ê¸°</button>
                    <button class='filter-btn' onclick="toggleFilter('cardType', 'HERO')">ì˜ì›…</button>
                    ${hasLocation ? `<button class='filter-btn' onclick="toggleFilter('cardType', 'LOCATION')">ì¥ì†Œ</button>` : ''}
                </div>
                <div class='filter-row'>
                    <button class='filter-btn' onclick="toggleFilter('rarity', 'COMMON')">ì¼ë°˜</button>
                    <button class='filter-btn' onclick="toggleFilter('rarity', 'RARE')">í¬ê·€</button>
                    <button class='filter-btn' onclick="toggleFilter('rarity', 'EPIC')">íŠ¹ê¸‰</button>
                    <button class='filter-btn' onclick="toggleFilter('rarity', 'LEGENDARY')">ì „ì„¤</button>
                </div>
                <div class='filter-row' style='margin-top:5px; border-top:1px dashed #ddd; padding-top:5px;'>
                    ${setButtons}
                </div>
            </div>
        </div>
        
        <div id='devStats' class='dev-stats'></div>
        <div style='margin-bottom:10px; color:#555;'>ì²´í¬ë°•ìŠ¤ ì„ íƒ ì‹œ <b>ì œì™¸(Ban)</b> ë° ë±ì—ì„œ ìë™ ì‚­ì œ</div>
        <div class='btn' onclick='returnFromDev()'>ì™„ë£Œ ë° ì €ì¥</div>
        <div class='dev-layout' id='devGrid'></div>
    `;

    document.getElementById('devSearch').addEventListener('input', (e) => {
        devState.search = e.target.value.trim();
        updateDevGrid();
    });
}

function toggleFilter(category, value) {
    if (devState.filters[category].has(value)) devState.filters[category].delete(value);
    else devState.filters[category].add(value);
    updateDevGrid();
    updateFilterButtons();
}

function updateFilterButtons() {
    const buttons = document.querySelectorAll('.filter-btn');
    buttons.forEach(btn => {
        const text = btn.innerText;
        let isActive = false;
        if (devState.filters.classType.has('CLASS') && text === 'ì§ì—…') isActive = true;
        if (devState.filters.classType.has('NEUTRAL') && text === 'ì¤‘ë¦½') isActive = true;
        if (devState.filters.cardType.has('MINION') && text === 'í•˜ìˆ˜ì¸') isActive = true;
        if (devState.filters.cardType.has('SPELL') && text === 'ì£¼ë¬¸') isActive = true;
        if (devState.filters.cardType.has('WEAPON') && text === 'ë¬´ê¸°') isActive = true;
        if (devState.filters.cardType.has('HERO') && text === 'ì˜ì›…') isActive = true;
        if (devState.filters.cardType.has('LOCATION') && text === 'ì¥ì†Œ') isActive = true;
        if (devState.filters.rarity.has('COMMON') && text === 'ì¼ë°˜') isActive = true;
        if (devState.filters.rarity.has('RARE') && text === 'í¬ê·€') isActive = true;
        if (devState.filters.rarity.has('EPIC') && text === 'íŠ¹ê¸‰') isActive = true;
        if (devState.filters.rarity.has('LEGENDARY') && text === 'ì „ì„¤') isActive = true;
        
        const onclickAttr = btn.getAttribute('onclick');
        if (onclickAttr && onclickAttr.includes("toggleFilter('sets'")) {
            const match = onclickAttr.match(/'sets',\s*'([^']+)'/);
            if (match && devState.filters.sets.has(match[1])) isActive = true;
        }
        if (isActive) btn.classList.add('active'); else btn.classList.remove('active');
    });
}

function updateDevGrid() {
    const grid = document.getElementById('devGrid');
    const statsDiv = document.getElementById('devStats');
    grid.innerHTML = '';

    const filtered = baseDevCards.filter(card => {
        if (devState.search && !card.name.includes(devState.search)) return false;
        if (devState.filters.classType.size > 0) {
            const isNeutral = (card.cardClass === 'NEUTRAL' && (!card.classes || card.classes.includes('NEUTRAL')));
            const isClass = !isNeutral;
            let match = false;
            if (devState.filters.classType.has('CLASS') && isClass) match = true;
            if (devState.filters.classType.has('NEUTRAL') && isNeutral) match = true;
            if (!match) return false;
        }
        if (devState.filters.cardType.size > 0 && !devState.filters.cardType.has(card.type)) return false;
        if (devState.filters.rarity.size > 0) {
            let r = card.rarity || 'FREE';
            if (r === 'FREE') r = 'COMMON';
            if (!devState.filters.rarity.has(r)) return false;
        }
        if (devState.filters.sets.size > 0 && !devState.filters.sets.has(card.set)) return false;
        return true;
    });

    let classCount = 0; let neutralCount = 0;
    filtered.forEach(card => {
        const isNeutral = (card.cardClass === 'NEUTRAL' && (!card.classes || card.classes.includes('NEUTRAL')));
        if (isNeutral) neutralCount++; else classCount++;
    });
    statsDiv.innerHTML = `í‘œì‹œëœ ì¹´ë“œ: ì´ ${filtered.length}ì¥ (ì§ì—…: ${classCount} / ì¤‘ë¦½: ${neutralCount})`;

    filtered.forEach(card => {
        const box = document.createElement('div');
        box.className = 'dev-card-box';
        const img = document.createElement('div');
        img.className = 'dev-card-img';
        img.style.backgroundImage = `url('https://art.hearthstonejson.com/v1/render/latest/koKR/512x/${card.id}.png')`;
        img.onerror = function() { this.style.backgroundColor = '#ccc'; };
        const checkbox = document.createElement('div');
        checkbox.className = 'ban-checkbox';
        if (bannedCardIds.has(card.id)) checkbox.classList.add('checked');
        const inner = document.createElement('div'); inner.className = 'ban-inner'; checkbox.appendChild(inner);
        const overlay = document.createElement('div'); overlay.className = 'banned-overlay';
        checkbox.onclick = () => {
            if (bannedCardIds.has(card.id)) { bannedCardIds.delete(card.id); checkbox.classList.remove('checked'); }
            else { bannedCardIds.add(card.id); checkbox.classList.add('checked'); }
        };
        box.appendChild(img); box.appendChild(checkbox); box.appendChild(overlay); grid.appendChild(box);
    });
    updateFilterButtons(); 
}

function returnFromDev() {
    const originalLength = deck.length;
    deck = deck.filter(c => !bannedCardIds.has(c.id));
    const removedCount = originalLength - deck.length;
    if (removedCount > 0) alert(`${removedCount}ì¥ì˜ ì¹´ë“œê°€ ë±ì—ì„œ ì œì™¸ë˜ì—ˆìŠµë‹ˆë‹¤.\në‹¤ì‹œ ì„ íƒí•©ë‹ˆë‹¤.`);
    selectCards(false); 
}

// ------------------------------
// ë©”ì¸ ë¡œì§ (ë‹¨ìˆœí™”: 1í”½ ì „ì„¤, ì´í›„ ë…¸ì „ì„¤)
// ------------------------------
function selectCards(isFirst) {
  if (!allCardsData) return;
  const heroClass = heroClassMap[selectedHero];
  const activeSets = getActiveSets();

  let availableCards = allCardsData.filter(card => {
    if (bannedCardIds.has(card.id)) return false;
    
    // [ì¤‘ë³µ ì œí•œ ì¶”ê°€] 2ì¥ ì´ìƒì´ë©´ ì œì™¸
    const currentCount = deck.filter(c => c.id === card.id).length;
    if (currentCount >= 2) return false;

    const bannedTypes = ['ENCHANTMENT', 'HERO_POWER'];
    const bannedIds = ['GDB_905', 'AT_COIN', 'VAC_320']; 
    if (bannedTypes.includes(card.type)) return false;
    if (bannedIds.includes(card.id)) return false;
    if (card.name.trim().toLowerCase() === '???') return false;
    if (!['MINION', 'SPELL', 'WEAPON', 'HERO', 'LOCATION', 'QUEST'].includes(card.type)) return false;
    if (!card.set || !activeSets.includes(card.set)) return false;
    
    if (card.classes && card.classes.length > 0) {
        const isPureNeutral = card.classes.length === 1 && card.classes[0] === 'NEUTRAL';
        if (!isPureNeutral && !card.classes.includes(heroClass)) return false;
    } else {
        if (card.cardClass !== heroClass && card.cardClass !== 'NEUTRAL') return false;
    }
    return true;
  });

  if (selectedHero === 'ì£½ìŒì˜ ê¸°ì‚¬') {
    const current = getCurrentRunes();
    const maxBlood = current.blood;
    const maxFrost = current.frost;
    const maxUnholy = current.unholy;
    availableCards = availableCards.filter(card => {
        const runeCost = card.runeCost || { blood: 0, frost: 0, unholy: 0 };
        const cBlood = runeCost.blood || 0;
        const cFrost = runeCost.frost || 0;
        const cUnholy = runeCost.unholy || 0;
        const newMaxBlood = Math.max(maxBlood, cBlood);
        const newMaxFrost = Math.max(maxFrost, cFrost);
        const newMaxUnholy = Math.max(maxUnholy, cUnholy);
        return (newMaxBlood + newMaxFrost + newMaxUnholy) <= 3;
    });
  }

  // --- ì „ì„¤ ê·œì¹™ ì ìš© ---
  if (isFirst) {
      availableCards = availableCards.filter(c => c.rarity === 'LEGENDARY');
  } else {
      availableCards = availableCards.filter(c => c.rarity !== 'LEGENDARY');
  }

  let choices = [];
  if (availableCards.length < 3) {
      choices = availableCards;
  } else {
      while (choices.length < 3) {
          const idx = Math.floor(Math.random() * availableCards.length);
          const pick = availableCards[idx];
          if (!choices.some(c => c.id === pick.id)) choices.push(pick);
      }
  }

  renderChoiceScreen(choices);
}

function renderChoiceScreen(choices) {
  let runeHtml = '';
  if (selectedHero === 'ì£½ìŒì˜ ê¸°ì‚¬') {
      const runes = getCurrentRunes();
      const slots = [];
      for(let i=0; i<runes.blood; i++) slots.push('blood');
      for(let i=0; i<runes.frost; i++) slots.push('frost');
      for(let i=0; i<runes.unholy; i++) slots.push('unholy');
      while(slots.length < 3) slots.push('empty');
      runeHtml = `<div class='rune-container'>${slots.map(t=>`<div class='rune-slot rune-${t}'></div>`).join('')}</div>`;
  }

  content.innerHTML = `
      <div class='title'>ì¹´ë“œ ì„ íƒ (${deck.length}/30)</div>
      ${renderManaCurve()}
      ${runeHtml}
      <div class='layout'><div class='card-container' id='cards'></div><div class='deck' id='deck'></div></div>
      <div style='margin-top:20px;'><div class='btn dev-entry-btn' onclick='authDeveloperMode()'>ì¹´ë“œ í™•ì¸</div></div>
      `;
  
  updateDeck(); 
  const cardDiv = document.getElementById('cards');

  choices.forEach(card => {
    const wrapper = document.createElement('div'); wrapper.className = 'card-wrapper';
    const div = document.createElement('div'); div.className = 'card';
    div.style.backgroundImage = `url('https://art.hearthstonejson.com/v1/render/latest/koKR/512x/${card.id}.png')`;
    div.onerror = function() { this.style.backgroundColor = '#ccc'; this.innerText = card.name; };
    div.onclick = () => { addCardToDeck(card); };
    const name = document.createElement('div'); name.innerText = card.name; name.style.marginTop = '10px'; name.style.fontSize = '18px'; name.style.fontWeight = 'bold';
    const isClassCard = card.cardClass === heroClassMap[selectedHero] || (card.classes && card.classes.includes(heroClassMap[selectedHero]));
    if (isClassCard) name.style.color = '#0070DE'; 
    wrapper.appendChild(div); wrapper.appendChild(name); cardDiv.appendChild(wrapper);
  });
}

function addCardToDeck(card) {
    const rc = card.runeCost || { blood: 0, frost: 0, unholy: 0 };
    deck.push({ id: card.id, name: card.name, cost: card.cost, rarity: card.rarity, blood: rc.blood || 0, frost: rc.frost || 0, unholy: rc.unholy || 0, dbfId: card.dbfId });
    if(deck.length < 30) selectCards(false); else finishDeck();
}

function finishDeck() {
    updateDeck(); 
    const deckDiv = document.getElementById('deck').innerHTML;
    content.innerHTML = `
        <div class='title'>ë± ì™„ì„±!</div>
        <div class='layout'><div class='deck' style='height: auto; max-height: 70vh;'>${deckDiv}</div></div>
        <div class='btn' onclick='copyDeckList()'>í…ìŠ¤íŠ¸ ë³µì‚¬</div>
        <div class='btn' onclick='exportDeckCode()'>ë± ì½”ë“œ ë³µì‚¬</div>
        <div class='btn' onclick='mainScreen()'>ë‹¤ì‹œ í•˜ê¸°</div>
    `;
}

function copyDeckList() {
    const text = deck.map(c => `[${c.cost}] ${c.name}`).join('\n');
    navigator.clipboard.writeText(text).then(() => { alert('ë± ë¦¬ìŠ¤íŠ¸ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!'); });
}

// ------------------------------
// ë± ì½”ë“œ ì¸ì½”ë”© (Base64 + VarInt)
// ------------------------------
function encodeDeckCode() {
    if (!deck || deck.length === 0) return;

    // 1. í—¤ë”: 0x00, Version(1), Format(1=Wild)
    const bytes = [0, 1, 1];

    // 2. ì˜ì›…: Count(1), DBF ID
    writeVarInt(bytes, 1);
    writeVarInt(bytes, heroDbfIdMap[selectedHero] || 7); // ê¸°ë³¸ ì „ì‚¬

    // ì¹´ë“œ ë¶„ë¥˜ (1ì¥, 2ì¥, nì¥)
    const singles = [];
    const doubles = [];
    const multis = []; // íˆ¬ê¸°ì¥/ì•¼ìƒì´ë¼ nì¥ ê°€ëŠ¥í•˜ì§€ë§Œ í˜„ì¬ ë¡œì§ìƒ ìµœëŒ€ 2ì¥

    const cardCounts = {};
    deck.forEach(c => {
        const dbf = c.dbfId;
        cardCounts[dbf] = (cardCounts[dbf] || 0) + 1;
    });

    for (const [dbfStr, count] of Object.entries(cardCounts)) {
        const dbf = parseInt(dbfStr);
        if (count === 1) singles.push(dbf);
        else if (count === 2) doubles.push(dbf);
        else multis.push({ id: dbf, count: count });
    }

    // ì •ë ¬ (ì˜¤ë¦„ì°¨ìˆœ)
    singles.sort((a,b) => a - b);
    doubles.sort((a,b) => a - b);
    multis.sort((a,b) => a.id - b.id);

    // 3. 1ì¥ì§œë¦¬
    writeVarInt(bytes, singles.length);
    singles.forEach(id => writeVarInt(bytes, id));

    // 4. 2ì¥ì§œë¦¬
    writeVarInt(bytes, doubles.length);
    doubles.forEach(id => writeVarInt(bytes, id));

    // 5. nì¥ì§œë¦¬
    writeVarInt(bytes, multis.length);
    multis.forEach(item => {
        writeVarInt(bytes, item.id);
        writeVarInt(bytes, item.count);
    });

    // 6. ì‚¬ì´ë“œë³´ë“œ (ì—†ìŒ)
    bytes.push(0);

    // Base64 ì¸ì½”ë”©
    const base64 = btoa(String.fromCharCode.apply(null, bytes));
    return base64;
}

function writeVarInt(bytes, value) {
    while ((value & 0xFFFFFF80) !== 0) {
        bytes.push((value & 0x7F) | 0x80);
        value >>>= 7;
    }
    bytes.push(value & 0x7F);
}

function exportDeckCode() {
    try {
        const code = encodeDeckCode();
        navigator.clipboard.writeText(code).then(() => {
            alert('ë± ì½”ë“œê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!\ní•˜ìŠ¤ìŠ¤í†¤ì—ì„œ ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”.');
        });
    } catch(e) {
        console.error(e);
        alert('ë± ì½”ë“œ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
    }
}

loadCardData();
</script>

</body>
</html>